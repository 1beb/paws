# This file is generated by make.paws. Please do not edit here.
#' @importFrom paws.common new_operation new_request send_request
#' @include appmesh_service.R
NULL

#' Creates a new service mesh
#'
#' Creates a new service mesh. A service mesh is a logical boundary for
#' network traffic between the services that reside within it.
#' 
#' After you create your service mesh, you can create virtual nodes,
#' virtual routers, and routes to distribute traffic between the
#' applications in your mesh.
#'
#' @usage
#' appmesh_create_mesh(clientToken, meshName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name to use for the service mesh.
#'
#' @section Request syntax:
#' ```
#' appmesh$create_mesh(
#'   clientToken = "string",
#'   meshName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_create_mesh
appmesh_create_mesh <- function(clientToken = NULL, meshName) {
  op <- new_operation(
    name = "CreateMesh",
    http_method = "PUT",
    http_path = "/meshes",
    paginator = list()
  )
  input <- .appmesh$create_mesh_input(clientToken = clientToken, meshName = meshName)
  output <- .appmesh$create_mesh_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$create_mesh <- appmesh_create_mesh

#' Creates a new route that is associated with a virtual router
#'
#' Creates a new route that is associated with a virtual router.
#' 
#' You can use the `prefix` parameter in your route specification for
#' path-based routing of requests. For example, if your virtual router
#' service name is `my-service.local`, and you want the route to match
#' requests to `my-service.local/metrics`, then your prefix should be
#' `/metrics`.
#' 
#' If your route matches a request, you can distribute traffic to one or
#' more target virtual nodes with relative weighting.
#'
#' @usage
#' appmesh_create_route(clientToken, meshName, routeName, spec,
#'   virtualRouterName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which to create the route.
#' @param routeName &#91;required&#93; The name to use for the route.
#' @param spec &#91;required&#93; The route specification to apply.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router in which to create the route.
#'
#' @section Request syntax:
#' ```
#' appmesh$create_route(
#'   clientToken = "string",
#'   meshName = "string",
#'   routeName = "string",
#'   spec = list(
#'     httpRoute = list(
#'       action = list(
#'         weightedTargets = list(
#'           list(
#'             virtualNode = "string",
#'             weight = 123
#'           )
#'         )
#'       ),
#'       match = list(
#'         prefix = "string"
#'       )
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_create_route
appmesh_create_route <- function(clientToken = NULL, meshName, routeName, spec, virtualRouterName) {
  op <- new_operation(
    name = "CreateRoute",
    http_method = "PUT",
    http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes",
    paginator = list()
  )
  input <- .appmesh$create_route_input(clientToken = clientToken, meshName = meshName, routeName = routeName, spec = spec, virtualRouterName = virtualRouterName)
  output <- .appmesh$create_route_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$create_route <- appmesh_create_route

#' Creates a new virtual node within a service mesh
#'
#' Creates a new virtual node within a service mesh.
#' 
#' A virtual node acts as logical pointer to a particular task group, such
#' as an Amazon ECS service or a Kubernetes deployment. When you create a
#' virtual node, you must specify the DNS service discovery name for your
#' task group.
#' 
#' Any inbound traffic that your virtual node expects should be specified
#' as a `listener`. Any outbound traffic that your virtual node expects to
#' reach should be specified as a `backend`.
#' 
#' The response metadata for your new virtual node contains the `arn` that
#' is associated with the virtual node. Set this value (either the full ARN
#' or the truncated resource name, for example,
#' `mesh/default/virtualNode/simpleapp`, as the `APPMESH_VIRTUAL_NODE_NAME`
#' environment variable for your task group\'s Envoy proxy container in
#' your task definition or pod spec. This is then mapped to the `node.id`
#' and `node.cluster` Envoy parameters.
#' 
#' If you require your Envoy stats or tracing to use a different name, you
#' can override the `node.cluster` value that is set by
#' `APPMESH_VIRTUAL_NODE_NAME` with the `APPMESH_VIRTUAL_NODE_CLUSTER`
#' environment variable.
#'
#' @usage
#' appmesh_create_virtual_node(clientToken, meshName, spec,
#'   virtualNodeName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which to create the virtual node.
#' @param spec &#91;required&#93; The virtual node specification to apply.
#' @param virtualNodeName &#91;required&#93; The name to use for the virtual node.
#'
#' @section Request syntax:
#' ```
#' appmesh$create_virtual_node(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     backends = list(
#'       "string"
#'     ),
#'     listeners = list(
#'       list(
#'         healthCheck = list(
#'           healthyThreshold = 123,
#'           intervalMillis = 123,
#'           path = "string",
#'           port = 123,
#'           protocol = "http"|"tcp",
#'           timeoutMillis = 123,
#'           unhealthyThreshold = 123
#'         ),
#'         portMapping = list(
#'           port = 123,
#'           protocol = "http"|"tcp"
#'         )
#'       )
#'     ),
#'     serviceDiscovery = list(
#'       dns = list(
#'         serviceName = "string"
#'       )
#'     )
#'   ),
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_create_virtual_node
appmesh_create_virtual_node <- function(clientToken = NULL, meshName, spec, virtualNodeName) {
  op <- new_operation(
    name = "CreateVirtualNode",
    http_method = "PUT",
    http_path = "/meshes/{meshName}/virtualNodes",
    paginator = list()
  )
  input <- .appmesh$create_virtual_node_input(clientToken = clientToken, meshName = meshName, spec = spec, virtualNodeName = virtualNodeName)
  output <- .appmesh$create_virtual_node_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$create_virtual_node <- appmesh_create_virtual_node

#' Creates a new virtual router within a service mesh
#'
#' Creates a new virtual router within a service mesh.
#' 
#' Virtual routers handle traffic for one or more service names within your
#' mesh. After you create your virtual router, create and associate routes
#' for your virtual router that direct incoming requests to different
#' virtual nodes.
#'
#' @usage
#' appmesh_create_virtual_router(clientToken, meshName, spec,
#'   virtualRouterName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which to create the virtual router.
#' @param spec &#91;required&#93; The virtual router specification to apply.
#' @param virtualRouterName &#91;required&#93; The name to use for the virtual router.
#'
#' @section Request syntax:
#' ```
#' appmesh$create_virtual_router(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     serviceNames = list(
#'       "string"
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_create_virtual_router
appmesh_create_virtual_router <- function(clientToken = NULL, meshName, spec, virtualRouterName) {
  op <- new_operation(
    name = "CreateVirtualRouter",
    http_method = "PUT",
    http_path = "/meshes/{meshName}/virtualRouters",
    paginator = list()
  )
  input <- .appmesh$create_virtual_router_input(clientToken = clientToken, meshName = meshName, spec = spec, virtualRouterName = virtualRouterName)
  output <- .appmesh$create_virtual_router_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$create_virtual_router <- appmesh_create_virtual_router

#' Deletes an existing service mesh
#'
#' Deletes an existing service mesh.
#' 
#' You must delete all resources (routes, virtual routers, virtual nodes)
#' in the service mesh before you can delete the mesh itself.
#'
#' @usage
#' appmesh_delete_mesh(meshName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh to delete.
#'
#' @section Request syntax:
#' ```
#' appmesh$delete_mesh(
#'   meshName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_delete_mesh
appmesh_delete_mesh <- function(meshName) {
  op <- new_operation(
    name = "DeleteMesh",
    http_method = "DELETE",
    http_path = "/meshes/{meshName}",
    paginator = list()
  )
  input <- .appmesh$delete_mesh_input(meshName = meshName)
  output <- .appmesh$delete_mesh_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$delete_mesh <- appmesh_delete_mesh

#' Deletes an existing route
#'
#' Deletes an existing route.
#'
#' @usage
#' appmesh_delete_route(meshName, routeName, virtualRouterName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which to delete the route.
#' @param routeName &#91;required&#93; The name of the route to delete.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router in which to delete the route.
#'
#' @section Request syntax:
#' ```
#' appmesh$delete_route(
#'   meshName = "string",
#'   routeName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_delete_route
appmesh_delete_route <- function(meshName, routeName, virtualRouterName) {
  op <- new_operation(
    name = "DeleteRoute",
    http_method = "DELETE",
    http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}",
    paginator = list()
  )
  input <- .appmesh$delete_route_input(meshName = meshName, routeName = routeName, virtualRouterName = virtualRouterName)
  output <- .appmesh$delete_route_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$delete_route <- appmesh_delete_route

#' Deletes an existing virtual node
#'
#' Deletes an existing virtual node.
#'
#' @usage
#' appmesh_delete_virtual_node(meshName, virtualNodeName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which to delete the virtual node.
#' @param virtualNodeName &#91;required&#93; The name of the virtual node to delete.
#'
#' @section Request syntax:
#' ```
#' appmesh$delete_virtual_node(
#'   meshName = "string",
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_delete_virtual_node
appmesh_delete_virtual_node <- function(meshName, virtualNodeName) {
  op <- new_operation(
    name = "DeleteVirtualNode",
    http_method = "DELETE",
    http_path = "/meshes/{meshName}/virtualNodes/{virtualNodeName}",
    paginator = list()
  )
  input <- .appmesh$delete_virtual_node_input(meshName = meshName, virtualNodeName = virtualNodeName)
  output <- .appmesh$delete_virtual_node_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$delete_virtual_node <- appmesh_delete_virtual_node

#' Deletes an existing virtual router
#'
#' Deletes an existing virtual router.
#' 
#' You must delete any routes associated with the virtual router before you
#' can delete the router itself.
#'
#' @usage
#' appmesh_delete_virtual_router(meshName, virtualRouterName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which to delete the virtual router.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router to delete.
#'
#' @section Request syntax:
#' ```
#' appmesh$delete_virtual_router(
#'   meshName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_delete_virtual_router
appmesh_delete_virtual_router <- function(meshName, virtualRouterName) {
  op <- new_operation(
    name = "DeleteVirtualRouter",
    http_method = "DELETE",
    http_path = "/meshes/{meshName}/virtualRouters/{virtualRouterName}",
    paginator = list()
  )
  input <- .appmesh$delete_virtual_router_input(meshName = meshName, virtualRouterName = virtualRouterName)
  output <- .appmesh$delete_virtual_router_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$delete_virtual_router <- appmesh_delete_virtual_router

#' Describes an existing service mesh
#'
#' Describes an existing service mesh.
#'
#' @usage
#' appmesh_describe_mesh(meshName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh to describe.
#'
#' @section Request syntax:
#' ```
#' appmesh$describe_mesh(
#'   meshName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_describe_mesh
appmesh_describe_mesh <- function(meshName) {
  op <- new_operation(
    name = "DescribeMesh",
    http_method = "GET",
    http_path = "/meshes/{meshName}",
    paginator = list()
  )
  input <- .appmesh$describe_mesh_input(meshName = meshName)
  output <- .appmesh$describe_mesh_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$describe_mesh <- appmesh_describe_mesh

#' Describes an existing route
#'
#' Describes an existing route.
#'
#' @usage
#' appmesh_describe_route(meshName, routeName, virtualRouterName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which the route resides.
#' @param routeName &#91;required&#93; The name of the route to describe.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router with which the route is associated.
#'
#' @section Request syntax:
#' ```
#' appmesh$describe_route(
#'   meshName = "string",
#'   routeName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_describe_route
appmesh_describe_route <- function(meshName, routeName, virtualRouterName) {
  op <- new_operation(
    name = "DescribeRoute",
    http_method = "GET",
    http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}",
    paginator = list()
  )
  input <- .appmesh$describe_route_input(meshName = meshName, routeName = routeName, virtualRouterName = virtualRouterName)
  output <- .appmesh$describe_route_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$describe_route <- appmesh_describe_route

#' Describes an existing virtual node
#'
#' Describes an existing virtual node.
#'
#' @usage
#' appmesh_describe_virtual_node(meshName, virtualNodeName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual node resides.
#' @param virtualNodeName &#91;required&#93; The name of the virtual node to describe.
#'
#' @section Request syntax:
#' ```
#' appmesh$describe_virtual_node(
#'   meshName = "string",
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_describe_virtual_node
appmesh_describe_virtual_node <- function(meshName, virtualNodeName) {
  op <- new_operation(
    name = "DescribeVirtualNode",
    http_method = "GET",
    http_path = "/meshes/{meshName}/virtualNodes/{virtualNodeName}",
    paginator = list()
  )
  input <- .appmesh$describe_virtual_node_input(meshName = meshName, virtualNodeName = virtualNodeName)
  output <- .appmesh$describe_virtual_node_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$describe_virtual_node <- appmesh_describe_virtual_node

#' Describes an existing virtual router
#'
#' Describes an existing virtual router.
#'
#' @usage
#' appmesh_describe_virtual_router(meshName, virtualRouterName)
#'
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual router resides.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router to describe.
#'
#' @section Request syntax:
#' ```
#' appmesh$describe_virtual_router(
#'   meshName = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_describe_virtual_router
appmesh_describe_virtual_router <- function(meshName, virtualRouterName) {
  op <- new_operation(
    name = "DescribeVirtualRouter",
    http_method = "GET",
    http_path = "/meshes/{meshName}/virtualRouters/{virtualRouterName}",
    paginator = list()
  )
  input <- .appmesh$describe_virtual_router_input(meshName = meshName, virtualRouterName = virtualRouterName)
  output <- .appmesh$describe_virtual_router_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$describe_virtual_router <- appmesh_describe_virtual_router

#' Returns a list of existing service meshes
#'
#' Returns a list of existing service meshes.
#'
#' @usage
#' appmesh_list_meshes(limit, nextToken)
#'
#' @param limit The maximum number of mesh results returned by `ListMeshes` in paginated
#' output. When this parameter is used, `ListMeshes` only returns `limit`
#' results in a single page along with a `nextToken` response element. The
#' remaining results of the initial request can be seen by sending another
#' `ListMeshes` request with the returned `nextToken` value. This value can
#' be between 1 and 100. If this parameter is not used, then `ListMeshes`
#' returns up to 100 results and a `nextToken` value if applicable.
#' @param nextToken The `nextToken` value returned from a previous paginated `ListMeshes`
#' request where `limit` was used and the results exceeded the value of
#' that parameter. Pagination continues from the end of the previous
#' results that returned the `nextToken` value.
#' 
#' This token should be treated as an opaque identifier that is only used
#' to retrieve the next items in a list and not for other programmatic
#' purposes.
#'
#' @section Request syntax:
#' ```
#' appmesh$list_meshes(
#'   limit = 123,
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_list_meshes
appmesh_list_meshes <- function(limit = NULL, nextToken = NULL) {
  op <- new_operation(
    name = "ListMeshes",
    http_method = "GET",
    http_path = "/meshes",
    paginator = list()
  )
  input <- .appmesh$list_meshes_input(limit = limit, nextToken = nextToken)
  output <- .appmesh$list_meshes_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$list_meshes <- appmesh_list_meshes

#' Returns a list of existing routes in a service mesh
#'
#' Returns a list of existing routes in a service mesh.
#'
#' @usage
#' appmesh_list_routes(limit, meshName, nextToken, virtualRouterName)
#'
#' @param limit The maximum number of mesh results returned by `ListRoutes` in paginated
#' output. When this parameter is used, `ListRoutes` only returns `limit`
#' results in a single page along with a `nextToken` response element. The
#' remaining results of the initial request can be seen by sending another
#' `ListRoutes` request with the returned `nextToken` value. This value can
#' be between 1 and 100. If this parameter is not used, then `ListRoutes`
#' returns up to 100 results and a `nextToken` value if applicable.
#' @param meshName &#91;required&#93; The name of the service mesh in which to list routes.
#' @param nextToken The `nextToken` value returned from a previous paginated `ListRoutes`
#' request where `limit` was used and the results exceeded the value of
#' that parameter. Pagination continues from the end of the previous
#' results that returned the `nextToken` value.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router in which to list routes.
#'
#' @section Request syntax:
#' ```
#' appmesh$list_routes(
#'   limit = 123,
#'   meshName = "string",
#'   nextToken = "string",
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_list_routes
appmesh_list_routes <- function(limit = NULL, meshName, nextToken = NULL, virtualRouterName) {
  op <- new_operation(
    name = "ListRoutes",
    http_method = "GET",
    http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes",
    paginator = list()
  )
  input <- .appmesh$list_routes_input(limit = limit, meshName = meshName, nextToken = nextToken, virtualRouterName = virtualRouterName)
  output <- .appmesh$list_routes_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$list_routes <- appmesh_list_routes

#' Returns a list of existing virtual nodes
#'
#' Returns a list of existing virtual nodes.
#'
#' @usage
#' appmesh_list_virtual_nodes(limit, meshName, nextToken)
#'
#' @param limit The maximum number of mesh results returned by `ListVirtualNodes` in
#' paginated output. When this parameter is used, `ListVirtualNodes` only
#' returns `limit` results in a single page along with a `nextToken`
#' response element. The remaining results of the initial request can be
#' seen by sending another `ListVirtualNodes` request with the returned
#' `nextToken` value. This value can be between 1 and 100. If this
#' parameter is not used, then `ListVirtualNodes` returns up to 100 results
#' and a `nextToken` value if applicable.
#' @param meshName &#91;required&#93; The name of the service mesh in which to list virtual nodes.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' `ListVirtualNodes` request where `limit` was used and the results
#' exceeded the value of that parameter. Pagination continues from the end
#' of the previous results that returned the `nextToken` value.
#'
#' @section Request syntax:
#' ```
#' appmesh$list_virtual_nodes(
#'   limit = 123,
#'   meshName = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_list_virtual_nodes
appmesh_list_virtual_nodes <- function(limit = NULL, meshName, nextToken = NULL) {
  op <- new_operation(
    name = "ListVirtualNodes",
    http_method = "GET",
    http_path = "/meshes/{meshName}/virtualNodes",
    paginator = list()
  )
  input <- .appmesh$list_virtual_nodes_input(limit = limit, meshName = meshName, nextToken = nextToken)
  output <- .appmesh$list_virtual_nodes_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$list_virtual_nodes <- appmesh_list_virtual_nodes

#' Returns a list of existing virtual routers in a service mesh
#'
#' Returns a list of existing virtual routers in a service mesh.
#'
#' @usage
#' appmesh_list_virtual_routers(limit, meshName, nextToken)
#'
#' @param limit The maximum number of mesh results returned by `ListVirtualRouters` in
#' paginated output. When this parameter is used, `ListVirtualRouters` only
#' returns `limit` results in a single page along with a `nextToken`
#' response element. The remaining results of the initial request can be
#' seen by sending another `ListVirtualRouters` request with the returned
#' `nextToken` value. This value can be between 1 and 100. If this
#' parameter is not used, then `ListVirtualRouters` returns up to 100
#' results and a `nextToken` value if applicable.
#' @param meshName &#91;required&#93; The name of the service mesh in which to list virtual routers.
#' @param nextToken The `nextToken` value returned from a previous paginated
#' `ListVirtualRouters` request where `limit` was used and the results
#' exceeded the value of that parameter. Pagination continues from the end
#' of the previous results that returned the `nextToken` value.
#'
#' @section Request syntax:
#' ```
#' appmesh$list_virtual_routers(
#'   limit = 123,
#'   meshName = "string",
#'   nextToken = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_list_virtual_routers
appmesh_list_virtual_routers <- function(limit = NULL, meshName, nextToken = NULL) {
  op <- new_operation(
    name = "ListVirtualRouters",
    http_method = "GET",
    http_path = "/meshes/{meshName}/virtualRouters",
    paginator = list()
  )
  input <- .appmesh$list_virtual_routers_input(limit = limit, meshName = meshName, nextToken = nextToken)
  output <- .appmesh$list_virtual_routers_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$list_virtual_routers <- appmesh_list_virtual_routers

#' Updates an existing route for a specified service mesh and virtual
#' router
#'
#' Updates an existing route for a specified service mesh and virtual
#' router.
#'
#' @usage
#' appmesh_update_route(clientToken, meshName, routeName, spec,
#'   virtualRouterName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which the route resides.
#' @param routeName &#91;required&#93; The name of the route to update.
#' @param spec &#91;required&#93; The new route specification to apply. This overwrites the existing data.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router with which the route is associated.
#'
#' @section Request syntax:
#' ```
#' appmesh$update_route(
#'   clientToken = "string",
#'   meshName = "string",
#'   routeName = "string",
#'   spec = list(
#'     httpRoute = list(
#'       action = list(
#'         weightedTargets = list(
#'           list(
#'             virtualNode = "string",
#'             weight = 123
#'           )
#'         )
#'       ),
#'       match = list(
#'         prefix = "string"
#'       )
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_update_route
appmesh_update_route <- function(clientToken = NULL, meshName, routeName, spec, virtualRouterName) {
  op <- new_operation(
    name = "UpdateRoute",
    http_method = "PUT",
    http_path = "/meshes/{meshName}/virtualRouter/{virtualRouterName}/routes/{routeName}",
    paginator = list()
  )
  input <- .appmesh$update_route_input(clientToken = clientToken, meshName = meshName, routeName = routeName, spec = spec, virtualRouterName = virtualRouterName)
  output <- .appmesh$update_route_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$update_route <- appmesh_update_route

#' Updates an existing virtual node in a specified service mesh
#'
#' Updates an existing virtual node in a specified service mesh.
#'
#' @usage
#' appmesh_update_virtual_node(clientToken, meshName, spec,
#'   virtualNodeName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual node resides.
#' @param spec &#91;required&#93; The new virtual node specification to apply. This overwrites the
#' existing data.
#' @param virtualNodeName &#91;required&#93; The name of the virtual node to update.
#'
#' @section Request syntax:
#' ```
#' appmesh$update_virtual_node(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     backends = list(
#'       "string"
#'     ),
#'     listeners = list(
#'       list(
#'         healthCheck = list(
#'           healthyThreshold = 123,
#'           intervalMillis = 123,
#'           path = "string",
#'           port = 123,
#'           protocol = "http"|"tcp",
#'           timeoutMillis = 123,
#'           unhealthyThreshold = 123
#'         ),
#'         portMapping = list(
#'           port = 123,
#'           protocol = "http"|"tcp"
#'         )
#'       )
#'     ),
#'     serviceDiscovery = list(
#'       dns = list(
#'         serviceName = "string"
#'       )
#'     )
#'   ),
#'   virtualNodeName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_update_virtual_node
appmesh_update_virtual_node <- function(clientToken = NULL, meshName, spec, virtualNodeName) {
  op <- new_operation(
    name = "UpdateVirtualNode",
    http_method = "PUT",
    http_path = "/meshes/{meshName}/virtualNodes/{virtualNodeName}",
    paginator = list()
  )
  input <- .appmesh$update_virtual_node_input(clientToken = clientToken, meshName = meshName, spec = spec, virtualNodeName = virtualNodeName)
  output <- .appmesh$update_virtual_node_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$update_virtual_node <- appmesh_update_virtual_node

#' Updates an existing virtual router in a specified service mesh
#'
#' Updates an existing virtual router in a specified service mesh.
#'
#' @usage
#' appmesh_update_virtual_router(clientToken, meshName, spec,
#'   virtualRouterName)
#'
#' @param clientToken Unique, case-sensitive identifier that you provide to ensure the
#' idempotency of the request. Up to 36 letters, numbers, hyphens, and
#' underscores are allowed.
#' @param meshName &#91;required&#93; The name of the service mesh in which the virtual router resides.
#' @param spec &#91;required&#93; The new virtual router specification to apply. This overwrites the
#' existing data.
#' @param virtualRouterName &#91;required&#93; The name of the virtual router to update.
#'
#' @section Request syntax:
#' ```
#' appmesh$update_virtual_router(
#'   clientToken = "string",
#'   meshName = "string",
#'   spec = list(
#'     serviceNames = list(
#'       "string"
#'     )
#'   ),
#'   virtualRouterName = "string"
#' )
#' ```
#'
#' @keywords internal
#'
#' @rdname appmesh_update_virtual_router
appmesh_update_virtual_router <- function(clientToken = NULL, meshName, spec, virtualRouterName) {
  op <- new_operation(
    name = "UpdateVirtualRouter",
    http_method = "PUT",
    http_path = "/meshes/{meshName}/virtualRouters/{virtualRouterName}",
    paginator = list()
  )
  input <- .appmesh$update_virtual_router_input(clientToken = clientToken, meshName = meshName, spec = spec, virtualRouterName = virtualRouterName)
  output <- .appmesh$update_virtual_router_output()
  svc <- .appmesh$service()
  request <- new_request(svc, op, input, output)
  response <- send_request(request)
  return(response)
}
.appmesh$operations$update_virtual_router <- appmesh_update_virtual_router
